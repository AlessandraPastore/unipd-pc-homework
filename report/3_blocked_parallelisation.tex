\section{Blocked parallelization}\label{blocked_parallelization}

Although, the parallelization of the «for \(i\)» loop is simple and improves times, there remains the problem of synchronisation times being too high, remembering that a parallel algorithm does not start with the sequential algorithm.
We can think of a divide-and-conquer strategy: from the figure \cref{fig:data-dependencies-3} we can see that the same image applies whether the cell size is \(1 \times 1,  2 \times 2,  4 \times 4, \dots\) and that we can then divide the matrix into blocks and execute the sequential algorithm in parallel on sub-matrices.
In particular, the order of execution is as follows:
\begin{enumerate}
    \item diagonal cell \((h,h)\) since they are self-dependent (\cref{alg:block-diagonal} of \cref{alg:fw-blocked}).
    \item \(h\)-th row depends on itself and the previously after computed  \((h,h)\) cell (\cref{alg:block-row}  of \cref{alg:fw-blocked}).
    \item \(k\)-th column depends on itself and the previously after computed  \((h,h)\) cell (\cref{alg:block-column}  of \cref{alg:fw-blocked}).
    \item The rest of the matrix blocks as each of them depends on the \(h\)-th block of its row and the \(h\)-th block of its column (\cref{alg:block-other}  of \cref{alg:fw-blocked}).
\end{enumerate}

Performing the calculations in this order satisfies all the dependencies seen in \cref{fig:data-dependencies-3}, and one can start from this list to realise the parallel algorithm. \cref{fig:data-dependency-external-loop-parallel} shows the above steps.

Also in this case the outer loop cannot be paralleled but must always be executed sequentially.
Despite this, the matrix strategy makes it possible to reduce synchronisation times from \(n\times n\) to \(n/b + n/b + n/b \times n/b \approx n/b \times n/b\) so as \(b\) changes, the time required for synchronize after parallel execution changes.

\begin{figure}[htbp]
    \centering
    \begin{minipage}{\textwidth}
        \begin{algorithm}[H]
            \SetKwFunction{FFloyd}{Floyd}
            \SetKwProg{Pn}{Function}{:}{\KwRet}
            \Pn{\FFloyd{\(d,a,b,pred\)}}{
                let \(b\) size of the matrix \(C,A,B\)

                \For{\(h \in [0,b]\)}{
                    \For{\(i \in [0,b]\)}{
                        \For{\(j \in [0,b]\)}{
                            \If{\( a [ i , h ] + b [ h , j ] < d [ i , j ] \)} {
                                \( d [ i , j ] \leftarrow a [ i , h ] + b [ h , j ] \)

                                \( pred [ i , j ] \leftarrow pred [ h , j ] \)
                            }
                        }
                    }
                }
            }
            \SetKwFunction{FFloydBlocked}{Blocked Floyd Warshall}
            \SetKwProg{Pn}{Function}{:}{\KwRet}
            \Pn{\FFloydBlocked{\(W\)}}{
                let \(b\) number of partition

                \For{\(h \in [0,n,b]\)}{
                    \FFloyd(\(d[k:k+b,k:k+b],d[k:k+b,k:k+b],d[k:k+b,k:k+b],pred[k:k+b,k:k+b]\)) \label{alg:block-diagonal}

                    \For{\(j  \in [0,n,b] \setminus h\)} {
                        \FFloyd(\(d[k:k+b,j:j+b],d[k:k+b,k:k+b],d[k:k+b,j:j+b],pred[k:k+b,k:k+b]\)) \label{alg:block-row}
                    }

                    \For{\(i  \in [0,n,b]  \setminus h\)} {
                        \FFloyd(\(d[i:i+b,k:k+b],d[i:i+b,k:k+b],d[k:k+b,k:k+b],pred[k:k+b,k:k+b]\)) \label{alg:block-column}

                        \For{\(j  \in [0,n,b] \setminus h\)} {
                            \FFloyd(\(d[i:i+b,j:j+b],d[i:i+b,k:k+b],d[k:k+b,j:j+b],pred[k:k+b,k:k+b]\)) \label{alg:block-other}
                        }
                    }
                }
            }
            \caption{Floyd-Warshall's blocked algorithm}
            \label{alg:fw-blocked}
        \end{algorithm}
    \end{minipage}
\end{figure}

\begin{figure}[htbp]
    \centering
    \begin{subfigure}[t]{0.33\textwidth}
        \centering
        \includegraphics[width=\textwidth]{media/data_dependencies_4}
    \end{subfigure}
    \begin{subfigure}[t]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{media/data_dependencies_5}

    \end{subfigure}
    \caption{Graphical representation of the dependencies of the algorithm to calculate the cell values for each \(h\)}
    \label{fig:data-dependency-external-loop-parallel}
\end{figure}

\FloatBarrier
